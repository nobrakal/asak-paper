\begin{figure}

\[\small
\begin{array}{rclr}
\term
  & ::= & \var & \legend{Variable} \\
  & |   & \const & \legend{Constante} \\
  & |   & \apply\term{\many\term} & \legend{Application} \\
  & |   & \lam{\many\var}\term & \legend{Abstraction} \\
  & |   & \tlet\binding\term & \legend{Définition locale} \\
  & |   & \tletrec{\many\binding}\term & \legend{Définitions récursives} \\
  & |   & \apply\primitive{\many\term} & \legend{Appel d'une primitive} \\
  & |   & \switch\term{\many\branch}{\many\branch}{\term}
        & \legend{Branchement} \\
  & |   & \staticraise\nat{\many{\term}} & \legend{Saut local} \\
  & |   & \staticcatch{\term}\nat{\many{\var}}{\term} & \legend{Expression étiquetée} \\
  & |   & \trywith{\term}{x}{\term} & \legend{Expression étiquetée} \\
  & |   & \tifthenelse\term\term\term & \legend{Branchement conditionnel} \\
  & |   & \term ; \term & \legend{Séquencement} \\
  & |   & \twhile\term\term & \legend{Boucle non bornée} \\
  & |   & \tfor\var\term\term\term & \legend{Boucle bornée ascendante} \\
  & |   & \tfordown\var\term\term\term & \legend{Boucle bornée descendante} \\
  & |   & \tassign\var\term & \legend{Affectation} \\
  & |   & \tsend\term\term{\many\term} & \legend{Appel de méthode} \\
\binding & ::= & \var = \term & \legend{Définition} \\
\branch  & ::= & n \rightarrow \term & \legend{Branche} \\
\end{array}
\]
%% Les deux constructeurs suivants doivent être ignorés.
%%   | Levent of lambda * lambda_event
%%   | Lifused of Ident.t * lambda
\caption{La syntaxe de {\LambdaCode}
$\textrm{avec }
\nat \in \mathbb{N},
\var \in \mathcal{V},
\const \in \mathcal{C},
\primitive \in \mathcal{P}$.
}
\label{fig:lambda-syntax}
\end{figure}

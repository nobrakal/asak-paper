%!TEX root = root.tex

Dans cette section, nous faisons un retour d'expérience sur l'usage
d'{\Asak} pour la détection de clones dans les paquets~\Opam. Nous
commençons par détailler notre approche puis quelques résultats
préliminaires.

%% La redondance de code est un des fléaux de l'informatique moderne. Elle entraine inévitablement une grande difficulté de maintien (si l'on change une définition, il faudrait changer tous ses clones), de compréhension (nous ne dénombrons pas moins de 30 noms différents pour la célèbre fonction \iocaml{Option.map} dans la moitié des paquets \Opam) et des pertes de temps énorme consacrés à redéfinir des fonctions usuelles (nous dénombrons quelques 142 implémentations de ~\iocaml{Option.map}  dans la moitié des paquets \Opam).

\subsection{Approche utilisée}

Contrairement à l'environnement bien contrôlé des
copies~{\LearnOCaml}, chaque paquet~{\Opam} a un ensemble de
dépendances et une logique de compilation potentiellement complexe.
Pour ces paquets, la phase d'extraction des termes {\LambdaCode}
nécessite donc une configuration spécifique de la partie avant du
compilateur. Il serait difficile d'automatiser cette configuration à
partir du contenu des paquets. Nous avons préféré créer une version
personnalisée du compilateur~{\OCaml}~\cite{custom-ocaml} installable
dans \textit{switch} {\Opam}.

Le compilateur modifié instrumente la compilation standard par un
mécanisme de normalisation et d'exportation des termes~{\LambdaCode}.
Le dossier contenant le fichier source permet au compilateur de connaître le
paquet~{\Opam} en cours d'installation. Chaque terme collecté peut
ainsi être étiqueté par le nom du paquet~\Opam, par le nom du fichier
source et par le chemin du module de la définition dont il est issu.

À l'aide d'un serveur de calcul possédant 40 processeurs Intel(R)
Xeon(R) CPU E5-4640 v2 cadencé à 2.20GHz équipé de 756Go de RAM, nous
avons ensuite parallélisé les (tentatives d')installations de
l'ensemble des paquets~\Opam. Au bout de~$20$ heures, nous avons
obtenu un corpus de travail dont nous décrivons l'analyse avec~{\Asak} dans
la section suivante.

\subsection{Analyse des résultats}

Nous avons réussi à compiler $1250$ paquets sur les $2428$ paquets que
compte à ce jour le dépôt {\Opam} officiel. Tous les paquets n'ont pas
pu être installés pour les raisons suivantes :

\begin{itemize}
\item Certains paquets ne compilent pas avec {\OCaml} 4.08.1.
\item Certains paquets sont en conflit avec {\OCaml} 4.08.1.
\item Certains paquets dépendent de bibliothèques C non-installées.
\end{itemize}

\paragraph{Aspects quantitatifs}

Sur ces $1250$ paquets, nous avons extrait $360152$ définitions
strictement différentes. On a retiré de ce décompte les définitions
provenant de deux versions différentes d'une même paquet et qui
produisent la même empreinte.

En ne conservant que les empreintes des arbres de plus de~$30$ nœuds
(limite calculable en temps raisonnable de notre implémentation), ces
définitions ont été classées en $198841$ classes, dont $40935$ avec
strictement plus d'un élément (c'est-à-dire que nous avons identifié
au moins $40935$ doublons). Le tout a été calculé en $40$ minutes sur
la machine décrite dans la section précédente.

Donner les histogrammes, la moyenne, l'écart-type pour les
informations suivantes :
- la taille des classes
- le nombre de paquets qui contribuent à chaque classe
- la taille des définitions

\paragraph{Aspects qualitatifs}

Les classes comprenant plus de 50 éléments sont majoritairement:
\begin{itemize}
\item Soit des très petites fonctions (des variables globales ou des fonctions constantes).
\item Soit du code généré par des outils comme \verb|Coq|, \verb|Menhir|, \verb|AWS|...
\end{itemize}

Cependant, certaines classes représentent de véritables possibilités de factorisations. Par exemple, nous trouvons une classe contenant $134$ éléments comprenant toutes les définitions de la (célèbre) fonction \iocaml{Option.map}. Cette classe capture aussi les fonctions similaires concernant les types isomophes au type \iocaml{option}. Par exemple, cette classe contient la fonction (provenant du module \iocaml{Evd} de \verb|Coq|):

\begin{minted}{OCaml}
let map_evar_body f = function
  | Evar_empty -> Evar_empty
  | Evar_defined d -> Evar_defined (f d)
\end{minted}

- les paquets qui ont le plus de redondance interne

- les couples de paquets qui se ressemblent le plus

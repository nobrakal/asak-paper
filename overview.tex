Dans cette section, nous décrivons l'architecture de notre outil sur
un corpus d'exemple. Nous justifions nos choix de conception par la
même occasion.

\paragraph{Que produit {\Asak}?}
La figure~\ref{fig:example:sources} contient les cinq
exemples de définitions {\OCaml} qui forment un corpus jouet
qui va nous servir à illustrer le fonctionnement d'{\Asak}.
Le lecteur aura reconnu d'un coup d'{\oe}il la fonction classique qui
renvoie la liste mirroir d'une liste prise en argument et l'enseignant
aura reconnnu des réponses typiques d'étudiants apprenti-programmeurs
fonctionnels.

\begin{figure}

\begin{ocaml}
(* Code 1 *)
let rec rev l = match l with
    [] -> []
  |t::q -> rev q@[t]

(* Code 2 *)
let rec rev l =
  match l with
  | [] -> []
  | a::t -> (rev t)@[a]

(* Code 3 *)
let rec rev l = match l with
    [] | [_] -> l
  | t::q -> rev q@[t];;

(* Code 4 *)
let rev l=
  let rec rev_aux acc l=
    match l with
    |[]->acc
    |t::q->rev_aux (t::acc) q
  in rev_aux [] l

(* Code 5 *)
let rev l =
  match l with
    [] -> []
  |a::q -> let rec rev2 x y = match y with
        [] -> x
      |b::z -> rev2 (b::x) z in rev2 [] l

(* Code 6 *)
let rev l =
  List.fold_left (fun acc x -> x :: acc) [] l
\end{ocaml}

\label{fig:example:sources}
\caption{Un corpus jouet pour illustrer notre algorithme.}
\end{figure}

Sur ce corpus, notre outil produit le dendrogramme suivant~:

\begin{center}
\begin{tikzpicture}[sloped, scale=0.5]
\node (a)  at (-6,0)   {1};
\node (b)  at (-5,0)   {2};
\node (ab) at (-5.5,1) {};
\node (c) at (-3,0) {3};
\node (abc) at (-4, 2) {};
\node (d) at (-2,0) {4};
\node (e) at (-1,0) {5};
\node (de) at (-1.5,2) {};
\node (abcde) at (-3.5, 3) {};
\node (f) at (0,0) {6};
\node (all) at (-1, 4) {};
\node (root) at (-1,5) {};

\draw  (a) |- (ab.center);
\draw  (b) |- (ab.center);
\draw  (ab) |- (abc.center);
\draw  (c)  |- (abc.center);
\draw  (abc) |- (abcde.center);
\draw  (de)  |- (abcde.center);
\draw  (d)  |- (de.center);
\draw  (e)  |- (de.center);

\draw  (abcde) |- (all.center);
\draw  (f)     |- (all.center);

\draw (all)      |- (root.center);

\draw[->,-triangle 60] (-7,0) -- node[above]{dissimilarité} (-7,6);
\end{tikzpicture}
\end{center}

Un dendrogramme est un arbre binaire dont les n{\oe}uds représentent
des classes d'individus. Les feuilles de ce dendrogramme sont les
différentes versions de \texttt{rev}. Un dendrogramme fournit un
partitionnement hiérarchique d'un ensemble d'invididus: en le
parcourant d'une feuille vers sa racine, on découvre des classes
d'invididus de plus en plus dissimilaires à cette feuille ; en le
parcourant de sa racine vers ses feuilles, on découvre des séparations
successives en deux classes d'un ensemble d'individus maximisant
la dissimilarité entre les membres des deux classes. \yrg{Formulation
un peu lourde et peut-être incorrecte. Alexandre, tu peux m'aider?}

Dans le cas de ce corpus, le regroupement des définitions~$1$ et~$2$
est très naturel puisque ces deux définitions sont équivalentes à
quelques détails purement textuels près : la présence du \iocaml{|},
d'un retour à la ligne et d'un renommage. La définition~$3$ est proche
de cette première classe: elle en diffère seulement à cause d'un cas
d'analyse supplémentaire. Le regroupement des définitions~$4$ et~$5$
est assez naturel puisqu'elles suivent la même (et bonne!) stratégie
qui consiste à accumuler le résultat dans l'argument d'une fonction
auxilaire interne. Notons que ces deux définitions ne sont pas
syntaxiquement équivalence même si elles utilisent les mêmes ``ingrédients'' :
la définition~$5$ effectue une analyse par cas supplémentaire pour
traiter le cas de la liste vide de façon spécifique. Les deux classes~$(1-2)-3$
et~$4-5$ partagent le fait d'être des définitions récursives procédant par
analyse de cas : ces individus sont clairement séparés de la définition~$6$
qui s'appuie sur une spécialisation de la fonction~\iocaml{List.fold_left}.

\paragraph{Comment procède {\Asak}?}
Ce partitionnement semble somme toute assez naturel mais comment notre
outil l'a-t-il obtenu? Comme nous l'avons déjà écrit dans
l'introduction, le traitement de notre outil se décompose
essentiellement en trois étapes: (i) les programmes sources sont
normalisés pour ignorer les détails syntaxiques que nous jugeons
inessentiels ; (ii) on calcule une empreinte pour caractérisés la
structure et les ingrédients principaux des programmes normalisés ;
(iii) on applique un algorithme de partitionnement hiérarchique qui
s'appuie sur les empreintes.

\paragraph{Comment les définitions sont-elles normalisées?}
On aurait pu choisir de traduire les termes sources vers un langage conçu
pour l'occasion mais ce serait beaucoup de travail.

\paragraph{Comment les empreintes sont-elles calculées?}

\paragraph{Comment le partitionnement hiérarchique est-il effectué?}
